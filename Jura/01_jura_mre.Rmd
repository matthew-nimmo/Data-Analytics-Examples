---
title: "Technical Report"
subtitle: "Jura Resource Estimate"
author: "Kings Landing Inc"
date: "Effective date: `r strftime(Sys.Date(), '%e %B %Y')`"
output:
  bookdown::word_document2:
    toc: no
    number_sections: false
    reference_docx: amc_template.docx
  bookdown::html_document2:
bibliography: packages.bib
---

```{r setup, echo=FALSE, include=FALSE}
knitr::opts_chunk$set(
  warning = FALSE,
  message = FALSE,
  error = FALSE,
  echo = FALSE,
  include = TRUE,
  dpi = 180
)

BKWH <- grey(10:0/10)
YLORBR <- c("#FFFFD4", "#FED98E", "#FE9929", "#D95F0E", "#993404")
YLGRBL <- c("#ffffd9", "#41b6c4", "#081d58", "#081d58")

panel.hist <- function(x, ...)
{
  usr <- par("usr"); on.exit(par(usr))
  par(usr=c(usr[1:2], 0, 1.5) )
  h <- hist(x, plot=FALSE)
  breaks <- h$breaks; nB <- length(breaks)
  y <- h$counts; y <- y/max(y)
  rect(breaks[-nB], 0, breaks[-1], y, col="black")
}

panel.cor <- function(x, y, digits=2, prefix="", cex.cor=1.6, ...)
{
  usr <- par("usr"); on.exit(par(usr))
  par(usr=c(0, 1, 0, 1))
  r <- cor(x, y, use='complete.obs')
  txt <- format(c(r, 0.123456789), digits=digits)[1]
  txt <- paste(prefix, txt, sep="")
  text(0.5, 0.5, txt, cex=1.6)
}

panel.points <- function(x, y, ...)
{
  z <- densCols(x, y, colramp=colorRampPalette(c("black", "white")))
  #cols <- colorRampPalette(c("#000099", "#00FEFF", "#45FE4F","#FCFF00", "#FF9400", "#FF3100"))(256)
  cols <- viridis(256)

  df <- data.frame(x, y)
  df$dens <- col2rgb(z)[1,] + 1L
  df$col <- cols[df$dens]
  o <- order(df$dens)
  df <- df[o,]

  points(y~x, data=df, pch=20, col=col, cex=1.2)
}
```

```{r captions, echo=FALSE, results="hide", eval=FALSE}
FIG.PREFIX <- "14-"
fig <- captioner(prefix="Figure 14-", auto_space=FALSE)
tab <- captioner(prefix="Table 14-", auto_space=FALSE)

x <- read_excel("NORI_D_2020_Item_14.xlsx", sheet="figures")
for (i in 1:nrow(x)) {
  fig(x$name[i], x$title[i])
}

x <- read_excel("NORI_D_2020_Item_14.xlsx", sheet="tables")
for (i in 1:nrow(x)) {
  tab(x$name[i], x$title[i])
}

rm(x)
```

# Introduction

> Summarise the project.

Kings Landing have requested that AMC undertake a NI43-101 Mineral Resource estimate of their Jura copper deposit, 121 km from Braavos in the Principality of Dorne, Essos.

Casius Copper had undertaken a sampling program across the Jura deposit in early 1301. Sampling involved shallow auger drilling to collect a single composite sample of the near surface mineralisation. Sampling was conducted on a nominal 10 km by 10 km grid.

Based on the Casius Copper sampling from 1301 an initial Mineral Resource estimate for the Jura copper deposit was developed. The resource model was saved in GIS raster format spanning the coordinates UTM Easting 0 to 5.4, UTM Northing 0 to 6.4 with a cell size of 20m by 20m. The raster model contains 54 by 66 cells for a total of 3564 cells. Estimates of  grades were done on the raster point locations and aggregated up to larger panels with a nominal dimension of 3.5km by 3.5km. No geological domaining was performed, instead indicator kriging was used to estimate proportion of each lithology. Estimates for cadmium (Cd ppm), cobalt (Co ppm), chromium (Cr ppm), copper (Cu %), nickel (Ni ppm), lead (Pb ppm) and zinc (Zn ppm) were performed using Simple Kriging and Conditional Simulation.

All data used in the resource estimate in KL117 Zone K4W.

The initial Mineral Resource estimate for Jura is listed in Table \@ref(tab:jura-gt). The estimate is reported in accordance with the CIM "Estimation of Mineral Resources and Mineral Reserves Best Practice Guidelines".

```{r jura-gt, eval=FALSE}
if (file.exists("../data/C/C__NORI_D_gt_rep0__2020.csv")) {
  gt_rep0 <- read.csv("../data/C/C__NORI_D_gt_rep0__2020.csv",
                      stringsAsFactors=FALSE, na.strings="")
  kable(gt_rep0, format="markdown", row.names=FALSE,
        caption="Jura grade tonnage."
        digits=c(NA,NA,0,1,2,2,2,2,2,2,2,2))
}
```

<br>

## Previous resource estimates

There are no known previous resource estimates for the Jura copper deposit. This NI43-101 technical report documents the very first resource estimate for the deposit.

## Software

```{r include=FALSE, echo=FALSE, eval=TRUE}
source("./R/cache_data.R")
source("./R/cumprob.R")
source("./R/ppmt.R")
source("./R/sum_stats.R")
source("./R/declus.R")

full_pack <- c("knitr","gstat", "sp", "raster", "DMwR", "papeR", "viridis",
               "dplyr", "readxl", "readr", "sf", "ggplot2", "ggthemes",
               "hrbrthemes", "cowplot", "rgdal")
```

```{r include=TRUE, echo=FALSE, eval=TRUE}
ver_rs <- rstudioapi::versionInfo()
ver_r <- R.Version()
if (!exists("packages")) {
  packages <- full_pack
}
```

The open source R environment for statistical computing [@R-base] (`r ver_r$version.string` `r ver_r$nickname`) was used for preparing the sample data, data analysis, variography, spatial estimation and reporting. RStudio (version `r ver_rs$version` `r ver_rs$release_name`) was used as the integrated development environment along with the Rmarkdown technology to facilitate the automated compilation of the results and documentation.

```{r include=FALSE, echo=FALSE, eval=TRUE}
# Import the required packages.
for (p in packages) {
  if(!require(p, character.only=TRUE)) {
    install.packages(p)
  }
  require(p, character.only=TRUE)
}
knitr::write_bib(c("base", packages), "packages.bib")

# Build text.
txt <- paste(packages, paste0("[@R-", packages, "]"), collapse=", ")
txt <- gsub("([,] )([^,]*)$", " and \\2", txt)
```

Additional functions provided in R packages were also used for this data analysis. These included: `r txt`.

## Geology and Mineralisation

> Describe the geology and mineralisation of the deposit or prospect relevant for resource estimation.

> Describe the geology domaining (what, why and how).

# Data used for Mineral Resource estimation

Only shallow geology drillhole data was available for estimating the Mineral Resource for the Jura copper deposit. An arbitrary boundary string was also provided which defines the extent of the copper mineralisation.

## Boundaries and geological domains

> Outline any boundaries used to delimit the resource. Also discuss approach to geological and mineralisation domaining.

A boundary perimeter was provided as a GIS shape file. The boundary delimits the extent of the Mineral Resource estimate beyond the area covered by the sampling.

```{r echo=FALSE}
jura_bnd <- rgdal::readOGR("./data/A/bound.shp")
```

## Composite sample data

> Describe the process of preparing the sample data for estimation.

All sample data were provided in a single comma delimited (CSV) file. The data set contains assays for cadmium (Cd ppm), cobalt (Co ppm), chromium (Cr ppm), copper (Cu %), nickel (Ni ppm), lead (Pb ppm) and zinc (Zn ppm).

Automatic data type identification was utilized during importing of the nodule sample data from comma delimited and Microsoft Excel files. Conversion of the assay values results in values at or below or above detection limit (values prefixed with < or >) are set to detection limit (leading < or > are automatically removed). This is the preferred behaviour as values less than or above detection limit are censored data and it is not known by how much the value is below or above the detection limit. To avoid bias it is better to set the values to detection limit.

```{r}
A__AH <- cache_data("./data/A/A__jura_auger_samples.rds", function() {
  # Import csv file.
  df <- read.csv("./data/A/jura_modified.csv", header=TRUE,
                 na.strings=c("NA","","-","-9"), stringsAsFactors=FALSE)
  return(df)
}, out.csv=FALSE)
```

The column names were renamed following AMC standard naming convention where assays are labelled using [element symbol]_[unit]. All assays are in parts per million (ppm) except copper which is in percent (%).

```{r}
B__AH <- cache_data("./data/B/B__jura_auger_samples.rds", function() {
  # Select and rename columns.
  df <- dplyr::select(A__AH, X=Xloc, Y=Yloc, rock=Rock,
                      cd_ppm=Cd, co_ppm=Co, cr_ppm=Cr, cu_pct=Cu,
                      ni_ppm=Ni, pb_ppm=Pb, zn_ppm=Zn)
  df$SEQ <- ifelse(df$rock == "SEQ", 1, 0)
  df$KIM <- ifelse(df$rock == "KIM", 1, 0)
  df$QUA <- ifelse(df$rock == "QUA", 1, 0)
  df$ARG <- ifelse(df$rock == "ARG", 1, 0)
  df$POR <- ifelse(df$rock == "POR", 1, 0)
  return(df)
}, out.csv=FALSE)
```

Spatial distribution of the sample data is shown in Figure \@ref(fig:ah-samp).

> Describe the plot.

```{r ah-samp, fig.width=4, fig.height=4, fig.cap="Jura sample locations."}
z <- factor(B__AH$rock)
plot(B__AH$X, B__AH$Y, pch=16, cex=0.8, asp=1,
     frame.plot=FALSE, col=unclass(z),
     xlab="UTM X (km)", ylab="UTM Y (km)")
lines(jura_bnd, col="red", lwd=2)
legend("topleft", legend=levels(z), col=1:nlevels(z), pch=16, cex=0.6)
rm(z)
```

The sample data provided by Kings Landing include `r nrow(B__AH)` samples. The sampling and assaying method is not known. Summary statistics of the primary assays are listed in Table \@ref(tab:ah-sumstat).

```{r ah-sumstat}
flds <- names(B__AH)[sapply(B__AH, is.numeric)]
x <- as.data.frame(t(sapply(B__AH[, flds], sum_stats, simplify="data.frame")))
kable(x, format="markdown", caption="Assay summary statistics.")
rm(x, flds)
```

<br>

```{r}
flds_est <- c("cd_ppm","co_ppm","cr_ppm","cu_pct",
              "ni_ppm","pb_ppm","zn_ppm")
txt <- paste(flds_est, collapse=", ")
txt <- gsub("([,] )([^,]*)$", " and \\2", txt)
```

The assay variables that were used for resource estimation include `r txt`.

The cumulative probability plots of the sample assay data within the Jura copper deposit are provided in (Figure \@ref(fig:ah-cumprob)).

> Describe the plots.

```{r ah-cumprob, fig.width=9, fig.height=9, fig.cap="Cumulative probability plots of sample assay data."}
par(mfrow=c(3,3), oma=c(1,0,0,0))

for (i in flds_est) {
  cumprob(as.formula(paste(i, "~ rock")), data=B__AH,
          main="", xlab=i, pch=16, cex=0.9)
}
```

The cumulative probability plots of the sample assay data within the Jura copper deposit are provided in (Figure \@ref(fig:ah-box)).

> Describe the plots.

```{r ah-box, fig.width=7, fig.height=7, fig.cap="Boxplots of assays by rock."}
par(mfrow=c(3,3), mar=c(5.1,6.1,1.1,1.1))

for (i in flds_est) {
  boxplot(as.formula(paste(i, "~ rock")), data=B__AH,
          horizontal=TRUE, pch=16, cex=0.9, frame.plot=FALSE, las=2,
          main="", ylab="", xlab=i)
}
```

### Sample clustering

The sample data contains a number of clusters. A cell declustering algorithm was applied to the sample locations. The spatially weighted means and unweighted means for the assays are shown in Table \@ref(tab:ah-cmeans). The weighted mean values can be used to compare with the block model estimated values for validation of grade estimation.

> Discuss results of comparison of means.

```{r ah-cmeans}
x <- sapply(B__AH[,flds_est], mean, na.rm=TRUE)
x <- round(x, 2)

y <- sapply(flds_est, function(i) {
  j <- !is.na(B__AH[[i]])
  wts <- declus(B__AH[j,i], x=B__AH$X[j], y=B__AH$Y[j],
                yanis=1.0, zanis=1.0, ncell=10,
                cmin=0.2, cmax=5, noff=1, minmax=0)
  wts <- ifelse(j, wts, 0)
  sum(B__AH[j,i] * wts, na.rm=TRUE) / sum(wts, na.rm=TRUE)
})
y <- round(y, 2)

z <- data.frame(mean=x, `wtd mean`=y)
kable(z, caption="Assay mean and declustered mean.")
rm(x, y, z)
```

<br>

### Outliers within the sample data

Outliers (extreme values) detected using the Local Outlier Factor algorithm are highlighted in the pairs plot shown in Figure \@ref(fig:ah-pairs) (red crosses) and listed in Table \@ref(tab:ah-out1). The spatial location of the identified outliers is shown in Figure \@ref(fig:ah-out2)

> Discuss plot.

```{r ah-pairs, fig.width=6.6, fig.height=6.6, fig.cap="Pairs plots showing identified outliers."}
panel.points2 <- function(x, y, ...)
{
  z <- densCols(x, y, colramp=colorRampPalette(c("black", "white")))
  cols <- viridis(256)

  df <- data.frame(x, y)
  df$dens <- col2rgb(z)[1,] + 1L
  df$col <- cols[df$dens]
  o <- order(df$dens)
  df <- df[o,]

  out <- rep(FALSE, nrow(df))
  out[outliers] <- TRUE
  out <- out[o]

  points(y~x, data=df[!out,], pch=20, col=col, cex=1.2)
  if (any(out)) {
    points(y~x, data=df[out,], pch=3, col="black", cex=1.2, lwd=1)
  }
}

x <- B__AH[, flds_est]

indx <- complete.cases(x)
outlier.scores <- rep(0, nrow(x))
outlier.scores[indx] <- lofactor(x[indx, ], k=5)
outliers <- order(outlier.scores, decreasing=TRUE)[1:5]

n <- nrow(x)
pch <- rep(19, n)
pch[outliers] <- 3
col <- rep("black", n)
col[outliers] <- "red"
cex <- rep(0.8, n)
cex[outliers] <- 1

pairs(x, cex=cex, gap=0.5, pch=pch, col=col,
      upper.panel=panel.cor, lower.panel=panel.points2)
rm(x, indx, n, pch, col, cex)
```

```{r ah-out1}
flds <- c("X","Y","rock", flds_est)
x <- B__AH[sort(outliers), flds]
#row.names(x) <- outliers
kable(x, format="markdown", digit=1, row.names=TRUE,
      caption="List of identified outliers.")
rm(x)
```

<br>

```{r ah-out2, fig.width=4, fig.height=4, fig.cap="Location of identified outliers."}
par(mar=c(5.1,4.1,1.1,1.1))

i <- 1:nrow(B__AH) %in% outliers 
plot(B__AH$X[!i], B__AH$Y[!i], col="black", pch=16, cex=0.6,
     xlab="UTM X (m)", ylab="UTM Y (m)", asp=1, frame.plot=FALSE)
points(B__AH$X[i], B__AH$Y[i], pch=19, cex=0.8, col="red")
lines(jura_bnd, col="red", lwd=2)
legend("topleft", "Identified potential outliers", horiz=TRUE,
       col="red", pch=19, cex=0.7, bty="n", inset=c(0, -0.06), xpd=TRUE)

rm(i)
```

### Top-cuts

To help minimise the influence of outliers on the estimation of local grades the most common approach is to trim those outliers to some arbitrary value (typically the 97.5, 98 or 99 percentile or mean plus twice standard deviation). Table \@ref(tab:ah-topcut) lists the top-cuts that could be considered using these methods. Other methods include selecting the trim value by inspecting log-probability plots and looking for where the distribution breaks down in the high values, or looking at the inflection point in a mean-variance plot.

```{r ah-topcut}
func <- function(x) {
  y <- na.omit(x)
  v <- c(quantile(y, probs=c(0.975,0.98,0.99)),
         mean(y)+2*sd(y), median(y)+1.5*IQR(y))
  v <- round(v, 1)
  names(v) <- c("97.5%","98.0%","99.0%","Mean+2*sd","Median+1.5*IQR")
  return(v)
}

x <- t(sapply(B__AH[, flds_est], func))
x <- as.data.frame(x)
kable(x, format="markdown", caption="List of possilbe top-cuts for each assay.")
rm(x)
```

<br>

The selected top-cuts (values to trim the sample assays by) applied to the sample data are listed in Table \@ref(tab:top-cuts1) and are shown as a red line in the plots provided in Figure \@ref(fig:top-cuts2). The mean-variance curves (Figure \@ref(fig:mean-var)) by top-cut value show that the selected top-cut values occur where at the inflection point in mean curve where decreasing top-cut would result in a rapidly decreasing mean value. Above the top-cut values the means are relatively stable.

```{r top-cuts1}
top_cuts <- data.frame(Variable=flds_est,
                       Cut=c(3.8,15.2,59.1,16.5,35.2,144,146))
kable(top_cuts, caption="Assay top-cut values.")
```

<br>

```{r top-cuts2, fig.width=6, fig.height=2, fig.cap="Histogram, log-probability and mean value byplots to assess top-cuts."}
func <- function(cutval, x) {
  y <- ifelse(x > cutval, cutval, x)
  v <- c(Mean=mean(y), Var=var(y))
}

flds <- top_cuts$Variable
cutval <- top_cuts$Cut
names(cutval) <- flds

#par(mar=c(5.1,4.1,2.1,4.1), mfrow=c(5, 3), cex=1)

for (i in flds) {
  par(mfcol=c(1,3), mar=c(6.1,4.1,2.1,2.1))

  x <- na.omit(B__AH[[i]])
  cv <- cutval[[i]]

  hist(x, breaks="FD", main="", xlab=i)
  abline(v=cv, col="red")
  mtext(cv, side=3, line=0, at=cv, cex=0.55, col="red")

  cumprob(x, main="", xlab=i)
  abline(v=cv, col="red")
  mtext(cv, side=3, line=0, at=cv, cex=0.55, col="red")

  par(mar=c(6.1,4.1,3.1,5.1))
  q <- round(quantile(x, probs=(75:100)/100), 2)
  y <- sapply(q, func, x)
  plot(q, y[1,], type="l", col="black", frame.plot=FALSE,
       xlab="Trim value", ylab="Mean", main="")
  abline(v=cv, col="red")
  mtext(cv, side=3, line=0, at=cv, cex=0.55, col="red")
  par(new=TRUE)
  plot(q, y[2,], type="l", col="blue", axes=FALSE, xlab="", ylab="")
  axis(side=4)
  mtext(side=4, line=3, "Variance", col="blue", cex=0.7)
  title(main=i, line=2)
}

rm(flds, cutval, x, cv, q, y, i)
```

### Missing value imputation

> Include if you have missing values.

## Representativeness of sampling

> Discuss representativeness of the sampling.

# Domaining

> Describe process of defining/interpreting geological domains.

No geological interpretation was performed.

Geological domains are defined by rock stratigraphy (age) and include Sequanian (SEQ), Kimmeridgian (KIM), Quaternary (QUA), Argovian (ARG) and Portlandian (POR).

Within the boundary of the Jura deposit no areas were excluded from the resource estimate.

```{r}
M__IND <- cache_data("./data/M/M__jura_rock_ind.rds", function() {
  gr <- raster(ncols=54, nrows=66, xmn=0, xmx=5.4, ymn=0, ymx=6.4)

  x <- B__AH
  x <- x[complete.cases(x), ]
  coordinates(x) <- ~ X + Y
  z <- as.data.frame(coordinates(gr))
  names(z) <- c("X","Y")
  coordinates(z) <- ~ X + Y

  set.seed(9)
  flds <- c("SEQ","KIM","QUA","ARG","POR")
  y <- lapply(flds, function(i) {
    z <- krige(as.formula(paste(i, "~ 1")), x, newdata=z, nsim=0,
              model=vgm(0.3, "Sph", 1.5, add.to=vgm(0.6, "Sph", 0.5, 0.1)),
              maxdist=3, nmin=1, nmax=10, omax=3)
    z@data$var1.pred[is.na(z@data$var1.pred)] <- 0
    z@data$var1.pred <- pmax(0, pmin(1, z@data$var1.pred))
    raster(SpatialPixelsDataFrame(z@coords, z@data))
  })
  y <- brick(y)
  names(y) <- flds
  y <- rasterize(jura_bnd, y, mask=TRUE)

  return(y)
}, out.csv=FALSE)
```

A geological raster model was constructed by kriging the dummy lithology variables SEQ, KIM, QUA, ARG and POR. The raster origin was set at 0 UTM X and 0 UTM Y coordinates. Cell dimensions of 20m by 20mm was used resulting in a raster with 54 cells in the X and 66 cells in the Y for a total of 3564 cells. A single lithology layer was constructed by taking the maximum probability across the estimated indicators for each cell and the cell value set to the column name that corresponds to the maximum value.

Figure \@ref(fig:ind-ok) shows the indicator maps for each lithology while Figure \@ref(fig:ind-rock) is the constructed lithology map derived from the indicator maps.

```{r ind-ok, fig.width=9, fig.height=6, fig.cap="Lithology indicator maps created using Indicator Kriging."}
par(oma=c(1,1,1,1))
plot(M__IND, asp=1, col=viridis(20),
     addfun=function() {
       #points(B__AH$X, B__AH$Y, pch="+", col="white")
       box(col="white")
       lines(jura_bnd, col="red", lwd=2)
})
```

# Data transformations

Projection Pursuit Multivariate Transform was applied to the sample data.

Projection Pursuit Multivariate Transform (PPMT) is a method to transform multivariate numeric data into a multigaussian. The transform aims to remove all bivariate correlations between the variables making them independent and to transform each variable to a normal distribution. The transform allows for independent random simulation of gaussian variables which are then back-transformed into the original multivariate space where all bivariate correlations and trends are restored. The transform is useful in conditional simulations and kriging where the variables are assumed to be independent and gaussian. The transform ensures that, even when using different variograms for each variable, the bivariate relationships are maintained and any desired ratios are replicated.

```{r}
C__AH <- cache_data("./data/C/C__jura_samples_ppmt.rds", function() {
  x <- B__AH
  x$rowid <- 1:nrow(x)
  fldsy <- flds_est
  fldsx <- setdiff(names(x), fldsy)
  indx <- complete.cases(x[, fldsy])
  x <- x[indx, ]

  flds <- top_cuts$Variable
  cutval <- top_cuts$Cut
  names(cutval) <- flds
  for (i in flds) {
    x[[i]] <- ifelse(x[[i]] > cutval[[i]], cutval[[i]], x[[i]])
  }

  set.seed(3)
  y_ppmt <- ppmt(x[, fldsy])
  y_ppmt$Y <- cbind(x[, fldsx], y_ppmt$Y)

  return(y_ppmt)
})
```

# Spatial continuity

Spatial continuity of grades cadmium, cobalt, chrome, copper, nickel, lead and zinc were assessed using geostatistics. The backscatter data and the manganese nodule sample data was used for calculating spatial variograms.

All samples within the Jura deposit boundary were used for analysis of spatial continuity. The PPMT transformed data was used for calculating the experimental variograms.

The direction of greatest continuity suggested by the variogram maps (Figure \@ref(fig:var-map)) is approximately 040&deg; or 140&deg;. This direction is an artefact of the sparseness of the sampling and the orientation of the sampling grid which is oriented 075 degrees, roughly parallel to the broad regional trend of the CCZ.

```{r}
dir_la <- c(140, 40, 140, 40, 40, 40, 140)
names(dir_la) <- flds_est
dir_sa <- ifelse(dir_la < 90, dir_la + 90, dir_la - 90)
```

```{r var-map, fig.width=9, fig.height=9, fig.cap="Variogram maps."}
my_col <- rev(viridis(3))
x <- C__AH$Y
#x <- B__AH
pp <- lapply(flds_est, function(i) {
  k <- complete.cases(x[, c("X","Y",i)])
  y <- x[k, c("X","Y",i)]

  g <- gstat(id=i, formula=formula(paste(i, "~ 1")),
             locations=~X+Y, data=y)
  vgm.map <- variogram(g, width=0.75, cutoff=6, map=TRUE,
                       cressie=FALSE, PR=FALSE, alpha=0, beta=0)

  x <- as.data.frame(vgm.map$map)
  p <- ggplot() +
    geom_raster(data=x, aes(x=dx, y=dy, fill=x[, i])) +
    xlab("dx (km)") + ylab("dy (km)") +
    ggtitle(i, subtitle=sprintf("Major axis = %03d", dir_la[i])) +
    scale_fill_gradientn(name=expression(gamma),
                         colours=my_col, na.value=my_col[3]) +
    theme_tufte() +
    theme(axis.text.x=element_text(size=7),
          axis.text.y=element_text(size=7)) +
    geom_abline(intercept=0, slope=tan((90-dir_la[i])*pi/180),
                linetype="dashed", color="white", size=0.5) +
    guides(fill=guide_colourbar(barwidth=0.8, barheight=5)) +
    coord_fixed()

  return(p)
})

plot_grid(plotlist=pp, ncol=3)
rm(pp, val, valt, my_col, x)
```

Spherical semi-variogram models were fitted to the experimental variograms using two structures for abundance, nickel, copper, and manganese while cobalt was fitted with only one structure. The experimental variograms for cobalt suggest very long ranges in the 075 degrees direction.

The variogram models used for estimating block nodule abundance, nickel, copper, manganese and cobalt are listed in Table \@ref(tab:fit-var) and illustrated in Figure \@ref(fig:exp-var).

```{r fit_var}
C__VAR <- data.frame(
  cd_ppm = c(0.1, 0.6, 0.5, 0.5, 0.5, 0.3, 1.5, 1.5, 1.5, dir_la[1]),
  co_ppm = c(0.1, 0.6, 0.5, 0.5, 0.5, 0.3, 1.5, 1.5, 1.5, dir_la[2]),
  cr_ppm = c(0.1, 0.6, 0.5, 0.5, 0.5, 0.3, 1.5, 1.5, 1.5, dir_la[3]),
  cu_pct = c(0.1, 0.6, 0.5, 0.5, 0.5, 0.3, 1.5, 1.5, 1.5, dir_la[4]),
  ni_ppm = c(0.1, 0.6, 0.5, 0.5, 0.5, 0.3, 1.5, 1.5, 1.5, dir_la[5]),
  pb_ppm = c(0.1, 0.6, 0.5, 0.5, 0.5, 0.3, 1.5, 1.5, 1.5, dir_la[6]),
  zn_ppm = c(0.1, 0.6, 0.5, 0.5, 0.5, 0.3, 1.5, 1.5, 1.5, dir_la[7])
)
row.names(C__VAR) <- c("Nugget",
                       "Sill 1", "Range 1 Omni", "Range 1 Major", "Range 1 Minor",
                       "Sill 2", "Range 2 Omni", "Range 2 Major", "Range 2 Minor",
                       "Major Dir.")
C__VAR <- rbind(C__VAR, Anisotropy=round(sapply(C__VAR, function(x) x[9] / x[8]), 2))

kable(C__VAR)
```

<br>

```{r}
M__VGM <- cache_data("./data/M/M__variograms.rds", function() {
  m <- lapply(flds_est, function(i) {
    x <- C__AH$Y[, c("X","Y",i)]
    j <- complete.cases(x) & !duplicated(x)
    x <- x[j, ]

    # Omni-directional variogram.
    vgm0 <- list(
      vgm = variogram(formula(paste(i, "~ 1")), ~X+Y, data=x, width=0.25),
      fit = vgm(C__VAR[6, i], "Sph", C__VAR[7, i], 0,
                add.to=vgm(C__VAR[2, i], "Sph", C__VAR[3, i], C__VAR[1, i]))
    )

    # Major variogram.
    vgm1 <- list(
      vgm = variogram(formula(paste(i, "~ 1")), ~X+Y, data=x,
                      width=0.25, alpha=dir_la[i], tol.hor=15),
      fit = vgm(C__VAR[6, i], "Sph", C__VAR[8, i], 0,
                add.to=vgm(C__VAR[2, i], "Sph", C__VAR[4, i], C__VAR[1, i]))
    )

    # Minor variogram.
    vgm2 <- list(
      vgm = variogram(formula(paste(i, "~ 1")), ~X+Y, data=x,
                      width=0.25, alpha=dir_sa[i], tol.hor=15),
      fit = vgm(C__VAR[6, i], "Sph", C__VAR[9, i], 0,
                add.to=vgm(C__VAR[2, i], "Sph", C__VAR[5, i], C__VAR[1, i]))
    )

    return(list(omni=vgm0, major=vgm1, minor=vgm2))
  })

  names(m) <- flds_est

  return(m)
})
```

```{r}
plot_var <- function(i, j, cutoff=c(6,6,6)) {
  m <- M__VGM[[i]]

  o <- par(mar=c(5.1,4.1,2.1,1.1), mfcol=c(1, 3), cex=0.8, oma=c(0,0,3,0))

  plot(m$omni$vgm$dist, m$omni$vgm$gamma, type="b", lty="dashed",
       pch=19, cex=0.7, xlim=c(0, cutoff[1]), ylim=c(0, 1.3),
       main="", frame.plot=FALSE, xlab="Distance (km)", ylab="Semivariance",
       col="black")
  title(main="Omni-Directional variogram", line=1.2)
  vl <- variogramLine(m$omni$fit, maxdist=cutoff[1])
  lines(vl$dist, vl$gamma, lwd=2, col="black")
  text(m$omni$vgm$dist, m$omni$vgm$gamma, labels=m$omni$vgm$np,
       cex=0.6, pos=3, offset=1, srt=90, xpd=TRUE)
  text(cutoff[1], 0.02, adj=1, cex=0.66, col=NULL,
       labels=bquote(~ gamma(h) == .(C__VAR[1,j]) +
                       .(C__VAR[2,j])*sph(.(C__VAR[3,j]),h) +
                       .(C__VAR[6,j])*sph(.(C__VAR[7,j]),h)))

  plot(m$major$vgm$dist, m$major$vgm$gamma, type="b", lty="dashed",
       pch=19, cex=0.7, xlim=c(0, cutoff[2]), ylim=c(0, 1.3),
       main="", frame.plot=FALSE, xlab="Distance (km)", ylab="Semivariance",
       col="black")
  title(main=sprintf("%03d Directional variogram", dir_la[i]), line=1.2)
  vl <- variogramLine(m$major$fit, maxdist=cutoff[2])
  lines(vl$dist, vl$gamma, lwd=2, col="black")
  text(m$major$vgm$dist, m$major$vgm$gamma, labels=m$omni$vgm$np,
       cex=0.6, pos=3, offset=1, srt=90, xpd=TRUE)
  text(cutoff[2], 0.02, adj=1, cex=0.66, col=NULL,
       labels=bquote(~ gamma(h) == .(C__VAR[1,j]) +
                       .(C__VAR[2,j])*sph(.(C__VAR[4,j]),h) +
                       .(C__VAR[6,j])*sph(.(C__VAR[8,j]),h)))

  plot(m$minor$vgm$dist, m$minor$vgm$gamma, type="b", lty="dashed",
       pch=19, cex=0.7, xlim=c(0, cutoff[3]), ylim=c(0, 1.3),
       main="", frame.plot=FALSE, xlab="Distance (km)", ylab="Semivariance",
       col="black")
  title(main=sprintf("%03d Directional variogram", dir_sa[i]), line=1.2)
  vl <- variogramLine(m$minor$fit, maxdist=cutoff[3])
  lines(vl$dist, vl$gamma, lwd=2, col="black")
  text(m$minor$vgm$dist, m$minor$vgm$gamma, labels=m$omni$vgm$np,
       cex=0.6, pos=3, offset=1, srt=90, xpd=TRUE)
  text(cutoff[3], 0.02, adj=1, cex=0.66, col=NULL,
       bquote(~ gamma(h) == .(C__VAR[1,j]) +
                .(C__VAR[2,j])*sph(.(C__VAR[5,j]),h) +
                .(C__VAR[6,j])*sph(.(C__VAR[9,j]),h)))

  mtext(j, side=3, line=1, outer=TRUE, font=par("font.main"), cex=par("cex.main"))
  par(o)
}
```

```{r exp-var, fig.width=8, fig.height=3.5, fig.cap="Experimental variograms."}
for (i in flds_est) {
  plot_var(i, i, cutoff=c(3,3,3))
}
```

```{r}
x <- t(C__VAR)
vario <- lapply(flds_est, function(i) {
  vgm(x[i,6], "Sph", x[i,8], anis=c(x[i,10], x[i,11]),
      add.to=vgm(x[i,2], "Sph", x[i,4], x[i,1], anis=c(x[i,10], x[i,11])))
})
names(vario) <- flds_est
rm(x)
```

## Grade estimation

The geology lithology raster model constructed using indicator kriging was used as the base model for grade estimation. Inverse distance weighting (power of 2) and simple kriging were used to estimate grades into the geological raster grid model. The 20 m by 20 m point estimates were aggregated to a raster with cell dimensions of 60 m by 60 m. This replicates a 3 by 3 (9) point discretization of a 60 m by 60 m panel.

```{r}
M__ROCK <- cache_data("./data/M/M__jura_rock.rds", function() {
  flds <- names(M__IND)
  #x <- raster::aggregate(M__IND, fact=3)
  x <- M__IND
  x <- which.max(x)
  x <- ratify(x)
  levels(x) <- list(data.frame(ID=1:length(flds), rock=flds))

  return(x)
}, out.csv=FALSE)
```

```{r ind-rock, fig.width=4, fig.height=4, fig.cap="Lithology map derived from the indicator kriging results."}
z <- factor(values(M__ROCK))
x <- data.frame(rock=z, coordinates(M__ROCK))
flds <- levels(M__ROCK)[[1]]$rock

ggplot() +
  geom_raster(data=x, aes(x=x, y=y, fill=rock), alpha=1) +
  scale_fill_viridis(na.value="white", option="magma",
                     discrete=TRUE, labels=flds) +
  xlab("UTM X (km)") + ylab("UTM Y (km)") +
  coord_equal() +
  theme_tufte() +
  theme(
    legend.position="right",
    legend.key.width = unit(3, "mm"),
    legend.key.height = unit(3, "mm"),
    legend.text = element_text(size=8)
  )
rm(x, z, flds)
```

Simple kriging was selected for spatial estimation, rather than ordinary kriging, as the projection pursuit multivariate transform (PPMT) was used to transform the variables into a multi-gaussian. Each of the transformed variables has a mean of zero and a standard deviation of 0. This is consistent with using sequential gaussian simulation using PPMT transformed variables.

The processed (top cuts applied, missing values imputed, historic samples declustered) and transformed (normal score for abundance and PPMT for grades) data was used for estimating grades. A minimum of 1 and a maximum of 10 samples were used in informing the estimates.

```{r}
M__IDW <- cache_data("./data/M/M__jura_idw.rds", function() {
  df <- C__AH$Y
  z <- sapply(flds_est, function(i) {
    x <- df[, c("X","Y",i)]
    x <- x[complete.cases(x), ]
    z <- as.data.frame(coordinates(M__ROCK))
    names(z) <- c("X","Y")

    y <- idw(as.formula(paste(i, " ~ 1")), ~ X + Y, data=x, newdata=z,
             idp=2, maxdist=6, nmin=1, nmax=10, omax=5)
    y$var1.pred
  })
  z <- as.data.frame(z)
  z <- as.data.frame(ppmt_inv(z, C__AH))
  names(z) <- flds_est
  z <- SpatialPixelsDataFrame(coordinates(M__ROCK), z)
  z <- brick(z)

  # Aggregate to parent cell.
  x <- raster::aggregate(z, fact=3)

  # Add back to sub-cell.
  x <- raster::extract(x, coordinates(M__ROCK))
  x <- as.data.frame(x)
  x <- SpatialPixelsDataFrame(coordinates(M__ROCK), x)
  x <- brick(x)
  x <- mask(x, M__ROCK)
  x$rock <- M__ROCK

  return(x)
}, out.csv=FALSE)
```

```{r}
M__SK <- cache_data("./data/M/M__jura_sk.rds", function() {
  df <- C__AH$Y
  z <- sapply(flds_est, function(i) {
    x <- df[, c("X","Y",i)]
    x <- x[complete.cases(x), ]
    coordinates(x) <- ~ X + Y
    z <- as.data.frame(coordinates(M__ROCK))
    names(z) <- c("X","Y")
    coordinates(z) <- ~ X + Y

    y <- krige(as.formula(paste(i, " ~ 1")), x, z, beta=0,
               model=vario[[i]], maxdist=6, nmin=1, nmax=10, omax=5)
    y$var1.pred
  })
  z <- as.data.frame(z)
  z <- as.data.frame(ppmt_inv(z, C__AH))
  names(z) <- flds_est
  z <- SpatialPixelsDataFrame(coordinates(M__ROCK), z)
  z <- brick(z)

  # Aggregate to parent cell.
  x <- raster::aggregate(z, fact=3)

  # Add back to sub-cell.
  x <- raster::extract(x, coordinates(M__ROCK))
  x <- as.data.frame(x)
  x <- SpatialPixelsDataFrame(coordinates(M__ROCK), x)
  x <- brick(x)
  x <- mask(x, M__ROCK)
  x$rock <- M__ROCK

  return(x)
}, out.csv=FALSE)
```

Comparison of the inverse distance (IDW) and simple kriging estimates with sample data are illustrated in Figure \@ref(fig:comp-est). The cumulative probability plots show that the simple kriging panel estimates are similar to the inverse distance panel estimates. Both estimates are smoother than the samples.

```{r comp-est, fig.width=7, fig.height=7, fig.cap="Log-probability plots comparing sample data with the IDW and SK estimates."}
par(mfrow=c(3,3))

for (i in flds_est) {
  xlim <- range(values(M__SK[[i]]),
                values(M__IDW[[i]]), B__AH[[i]], na.rm=TRUE)
  cumprob(values(M__SK[[i]]), pch=16, cex=0.5, col="red",
          main="", xlab=i, xlim=xlim)
  cumprob(values(M__IDW[[i]]), pch=16, cex=0.5, col="blue",
          main="", xlab=i, , xlim=xlim, add=TRUE)
  cumprob(B__AH[[i]], pch=16, cex=0.5, col="black",
          main="", xlab=i, xlim=xlim, add=TRUE)
}
plot(0, 0, xlim=c(0,1), ylim=c(0,1), axes=FALSE, xlab="", ylab="", type="n")
legend("topleft", legend=c("Samples","IDW","SK"),
       col=c("black","blue","red"), pch=16, bty="n")

rm(i, xlim)
```

## Mineral Resource classification

Because Mineral Resource classification for the Jura copper deposit is limited by the confidence in the estimates for copper, conditional simulation was used to estimate copper and assess estimation risk. Conditional Gaussian simulation was run 100 times using the same data and same estimation parameters and variogram model as used for kriging.

Confidence in the resource estimate was assessed using the probability of abundance being greater than +-15% of mean abundance over one quarter production (Measured) and one year production (Indicated) at 90% confidence.

> Outline assumption of annual production rate to derive panel size for a quarter of a years production.

The conditional simulation 20 m by 20 m panel estimates were aggregated up to 60 m by 60 m and 120 m by 120 m panels. The probability of abundance being greater than +-15% of copper over one quarter production (Measured) and one year production (Indicated) is shown in Figure \@ref(fig:sim-conf).

```{r}
M__SIM <- cache_data("./data/M/M__jura_sim.rds", function() {
  x <- B__AH[, c("X","Y","cu_pct")]
  x <- x[complete.cases(x), ]
  coordinates(x) <- ~ X + Y
  z <- as.data.frame(coordinates(M__ROCK))
  names(z) <- c("X","Y")
  coordinates(z) <- ~ X + Y

  set.seed(9)
  y <- krige(cu_pct ~ 1, x, newdata=z, beta=0, nsim=100,
             model=vario[["cu_pct"]], maxdist=3, nmin=1, nmax=10, omax=5)
  y <- SpatialPixelsDataFrame(y@coords, y@data)
  y <- brick(y)
  y <- mask(y, M__ROCK)
  y$rock <- M__ROCK

  return(y)
}, out.csv=FALSE)
```

Results of the conditional simulation of copper are presented in Figure \@ref(fig:sim-conf).

> Discuss impact of conditional simulation results to resource classification.

```{r sim-conf, fig.width=9, fig.height=4, fig.cap="Conditional Simulation results for Copper %."}
par(mfcol=c(1,2), mar=c(5.1,4.1,1.1,5.1), oma=c(0,0,2,0), bty="n")

zz <- aggregate(M__SIM, fact=3, fun=mean)
mn <- mean(zz)
zz <- abs(zz - mn) / mn
zz <- sum(zz > 0.15) / length(names(zz))
zz <- extract(zz, coordinates(M__ROCK))
zz <- data.frame(coordinates(M__ROCK), v=zz)
gridded(zz) <- ~ x + y
zz <- raster(zz)

plot(zz, asp=1, frame.plot=FALSE, col=viridis(5), breaks=c(0,0.1,0.15,0.2,0.3,1),
     main="Quarterly Production", xlab="UTM X (m)", ylab="UTM Y (m)")
points(B__AH$X, B__AH$Y, col="black", pch="+", cex=0.8)
mtext("Block Size: 60m x 60m", 1, 4, cex=0.7, adj=-0.25, xpd=TRUE)

zz <- aggregate(M__SIM, fact=6, fun=mean)
mn <- mean(zz)
zz <- abs(zz - mn) / mn
zz <- sum(zz > 0.15) / length(names(zz))
zz <- extract(zz, coordinates(M__ROCK))
zz <- data.frame(coordinates(M__ROCK), v=zz)
gridded(zz) <- ~ x + y
zz <- raster(zz)

plot(zz, asp=1, frame.plot=FALSE, col=viridis(5), breaks=c(0,0.1,0.15,0.2,0.3,1),
     main="Yearly Production", xlab="UTM X (m)", ylab="UTM Y (m)")
points(B__AH$X, B__AH$Y, col="black", pch="+", cex=0.8)

mtext("Probability of Abundance > +-15% of Mean Abundance", 3, 0.5, outer=TRUE,
      cex=par("cex.main"), font=par("font.main"))
mtext("Block Size: 120m x 120m", 1, 4, cex=0.7, adj=-0.25, xpd=TRUE)
```

The Mineral Resource was classified on the basis of the quality and uncertainty of the sample data and sample spacing in accordance with JORC 2012 definitions of Inferred, Indicated and Measured Mineral Resource.

> Describe classification rules for Measured, Indicated and Inferred Mineral Resource.

Mineral Resource classification boundaries delineating areas within the Jura copper deposit where sampling is sufficient for the resource to be categorized as either Indicated or Measured Mineral Resource were interpreted. These boundaries were used for reporting of the Mineral Resource by category, as per the JORC 2012 code.

## Estimation results

The 60 m by 60 m panel estimates were added back onto the 20 m by 20 m geological domaining GIS raster model. Resource categories Measured, Indicated and Inferred Mineral Resource were added to the 20 m by 20 m raster grid model using the perimeters defined by conditional simulation.

```{r}
M__MEAN <- cache_data("./data/M/M__jura_means.rds", function() {
  x <- lapply(flds_est, function(i) {
    reclassify(M__ROCK,
               matrix(c(1,1,mean(B__AH[[i]][B__AH$rock == "SEQ"], na.rm=TRUE),
                        2,2,mean(B__AH[[i]][B__AH$rock == "KIM"], na.rm=TRUE),
                        3,3,mean(B__AH[[i]][B__AH$rock == "QUA"], na.rm=TRUE),
                        4,4,mean(B__AH[[i]][B__AH$rock == "ARG"], na.rm=TRUE),
                        5,5,mean(B__AH[[i]][B__AH$rock == "POR"], na.rm=TRUE)),
                      byrow=TRUE, ncol=3), right=NA)
  })
  x <- brick(x)
  names(x) <- flds_est

  return(x)
}, out.csv=FALSE)
```

```{r r-means, fig.width=9, fig.height=6}
par(oma=c(1,1,1,2))
plot(M__MEAN, asp=1, col=viridis(7),
     addfun=function() {
       #points(B__AH$X, B__AH$Y, pch="+");
       box(col="white")
})
```

Results of the simple kriging (SK) estimates are shown in the spatial plots (Figure \@ref(fig:r-model)).

> Describe estimation results.

```{r r-model, fig.width=9, fig.height=9, fig.cap="Simple Kriging estimates informed by PPMT data."}
par(oma=c(1,1,1,1))
x <- M__SK[[flds_est]]
plot(x, asp=1, col=inferno(20),
     addfun=function() {
       points(B__AH$X, B__AH$Y, pch="+")
       box(col="white")
       #lines(dom_meas$XP, dom_meas$YP, col="purple", lwd=2)
       #lines(dom_ind$XP, dom_ind$YP, col="blue", lwd=2)
})
```

```{r r-class, fig.width=6, fig.height=4.7, eval=FALSE}
x <- M__SK$RESCAT
x <- data.frame(rescat=values(x), coordinates(M__SK))
x$rescat <- factor(x$rescat)
levels(x$rescat) <- c("Measured", "Indicated", "Inferred")

ggplot() +
  geom_raster(data=x, aes(x=x, y=y, fill=rescat), alpha=1) +
  scale_fill_viridis(na.value="grey90", discrete=TRUE) +
  coord_equal() +
  theme(
    legend.position="top",
    axis.line = element_blank(),
    axis.title.x = element_blank(),
    axis.title.y = element_blank(),
    panel.grid.major = element_line(color="#ebebe5", size=0.2),
    panel.grid.minor = element_blank(),
    panel.border = element_blank(),
    axis.text = element_text(size=8),
    plot.margin = margin(0.5, 1, 0.5, 0.5, "cm"),
    legend.key.width = unit(3, "mm"),
    legend.key.height = unit(3, "mm"),
    legend.spacing.x = unit(4, "mm"),
    legend.text = element_text(size=8),
    legend.title = element_blank()
  )
rm(x)
```

The Mineral Resource is reported in Table \@ref(tab:rep-gt0) at a nominal copper cut-off value of 0.1% Cu. Estimates were classified as either Measured, Indicated or Inferred Mineral Resource based on results of the conditional simulation of abundance.

```{r}
gt_rep0 <- cache_data("./data/M/M__jura_gt_rep0.csv", function() {
  rep_func <- function(RESCAT) {
    j <- !is.na(x$cu_pct)
    if (RESCAT>0) {
      j <- j & x$RESCAT == RESCAT
    }
    KM2.sum <- sum(KM2[j])
    MT.sum <- sum(MT[j])
    Cu_pct <- round(sum(x$cu_pct[j] * MT[j]) / MT.sum, 2)
    Co_ppm <- round(sum(x$co_ppm[j] * MT[j]) / MT.sum, 3)
    Ni_ppm <- round(sum(x$ni_ppm[j] * MT[j]) / MT.sum, 2)
    RESCAT <- switch(RESCAT+1, "All", "Measured", "Indicated", "Inferred")
    MT.sum <- round(MT.sum, 1)

    return(data.frame(RESCAT=RESCAT, MT=MT.sum,
                      Cu_pct=Cu_pct, Co_ppm=Co_ppm, Ni_ppm=Ni_ppm))
  }

  x <- as.data.frame(M__SK)
  x$density <- 1.8
  KM2 <- prod(res(M__SK))
  MT <- KM2 * x$density

  rep <- lapply(0, function(z) rep_func(z))
  rep <- do.call("rbind", rep)

  return(rep)
})
```

```{r}
gt_rep1 <- cache_data("./data/M/M__jura_gt_rep1.csv", function() {
  rep_func <- function(cutoff=4) {
    j <- !is.na(x$cu_pct) & x$cu_pct >= cutoff
    KM2.sum <- sum(KM2[j])
    MT.sum <- sum(MT[j])
    Cu_pct <- round(sum(x$cu_pct[j] * MT[j]) / MT.sum, 2)
    Co_ppm <- round(sum(x$co_ppm[j] * MT[j]) / MT.sum, 3)
    Ni_ppm <- round(sum(x$ni_ppm[j] * MT[j]) / MT.sum, 2)
    MT.sum <- round(MT.sum, 1)

    return(data.frame(Cutoff=cutoff, MT=MT.sum,
                      Cu_pct=Cu_pct, Co_ppm=Co_ppm, Ni_ppm=Ni_ppm))
  }

  x <- as.data.frame(M__SK)
  x$density <- 1.8
  KM2 <- prod(res(M__SK))
  MT <- KM2 * x$density

  minmax <- range(x$cu_pct, na.rm=TRUE)
  minmax <- floor(minmax)
  rep <- lapply(seq(minmax[1], minmax[2], by=1), function(z) rep_func(z))
  rep <- do.call("rbind", rep)

  return(rep)
})
```

```{r rep-gt0}
kable(gt_rep0, digits=1, caption="Jura Mineral Resource estimate")
```

<br>

The grade tonnage curves for Jura at various copper cutoffs are shown in Figure \@ref(fig:gt-curve).

```{r gt-curve, fig.width=5, fig.height=3.5, fig.cap="Jura grade-tonnage curve."}
par(mar=c(5,4,3,4)+0.1)

plot(gt_rep1$Cutoff, gt_rep1$MT, type="l", frame.plot=FALSE, col="blue", lwd=2,
     main="Jura Grade-Tonnage Curve", xlab="Cu (%)", ylab="",
     ylim=c(0, max(gt_rep1$MT)))
mtext("Tonnes (dry Mt)", side=2, line=3, col="blue")

par(new=TRUE)

plot(gt_rep1$Cutoff, gt_rep1$Cu_pct, xlab=NA, ylab=NA, type="l", lty="solid",
     axes=FALSE, col="red", lwd=2, ylim=c(0, max(gt_rep1$Cu_pct)))
axis(4, line=0)
mtext("Cu (%)", side=4, line=3, col="red")

abline(v=11, lty="dashed")
```

```{r}
# Export the model
x <- M__SK
x <- dropLayer(x, 1:3)
names(x) <- c("Cu","Ni","Pb","Zn","Rock")
writeRaster(x, "./data/M/M__jura_sk.nc", format="CDF", overwrite=TRUE)

x <- as.data.frame(rasterToPoints(x))
x$Rock <- (levels(M__SK$rock)[[1]]$rock)[x$Rock]
write.csv(x, "./data/M/M__jura_sk.csv", na="", row.names=FALSE)
```

# References
